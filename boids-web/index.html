<!DOCTYPE html>
<html>
<head>
    <title>Boids in the Blue (Web Port)</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
<canvas id="ocean"></canvas>

<script>
    // --- BOIDS IN THE BLUE (WEB PORT) ---
    // Standalone HTML5 version.

    // --- 1. SETTINGS ---
    const FISH_COUNT = 38;
    const JELLY_COUNT = 5;
    const ANGLER_COUNT = 3;
    const ORCA_COUNT = 3;

    const FISH_SIZE = 4;
    const ANGLER_SIZE = 4;
    const ORCA_SIZE = 5.5;
    
    const MAX_SPEED = 0.68;
    const MIN_SPEED = 0.20;
    const TURN_FACTOR = 0.04;

    // --- PHYSICS ---
    const VISUAL_RANGE = 130;
    const VISUAL_RANGE_SQ = VISUAL_RANGE * VISUAL_RANGE;
    const COHESION_FACTOR = 0.005;
    const ALIGNMENT_FACTOR = 0.05;
    const SEPARATION_FACTOR = 0.05;
    const SEPARATION_DIST = 35;
    const SEPARATION_DIST_SQ = SEPARATION_DIST * SEPARATION_DIST;
    const WANDER_FACTOR = 0.015;
    const PANIC_RANGE = 140;
    const ORCA_PANIC_RANGE = 200;
    const FEAR_FACTOR = 1.0;
    const MARGIN = 100;

    const WATER_TOP = "rgb(13, 26, 64)";
    const WATER_BOTTOM = "rgb(5, 10, 31)";
    const FISH_PALETTE = ['rgb(255, 128, 128)', 'rgb(255, 179, 77)', 'rgb(230, 230, 102)', 'rgb(77, 204, 230)', 'rgb(204, 153, 230)'];

    // --- MOUSE ---
    let mouseX = -9999, mouseY = -9999;

    // --- DAY/NIGHT ---
    let waterTop = WATER_TOP, waterBottom = WATER_BOTTOM, dnCounter = 0;

    function getDayNightColors(h) {
        const b = (Math.cos((h - 12) * Math.PI / 12) + 1) / 2;
        const r1 = Math.round(13+(26-13)*b), g1 = Math.round(26+(122-26)*b), b1 = Math.round(64+(176-64)*b);
        const r2 = Math.round(5+(13-5)*b), g2 = Math.round(10+(85-10)*b), b2 = Math.round(31+(128-31)*b);
        return { top: `rgb(${r1},${g1},${b1})`, bottom: `rgb(${r2},${g2},${b2})` };
    }

    // --- 2. SPRITES ---
    const SPRITES = {
        FISH: [[0,0,0,1,1,0,0], [0,1,1,1,1,1,0], [1,1,1,1,1,2,0], [1,1,1,1,1,1,0], [0,1,1,1,0,0,0], [0,0,1,0,0,0,0]],
        ANGLER: [[0,0,0,0,0,0,2,2,0,0], [0,0,0,0,0,0,1,1,0,0], [0,0,0,1,1,1,1,1,0,0], [0,0,1,1,1,1,1,1,1,0], [0,1,1,1,1,3,3,1,1,1], [1,1,1,1,1,1,1,1,1,1], [1,1,1,1,1,1,1,1,1,0], [0,1,1,1,1,1,1,0,0,0], [0,0,1,0,0,1,0,0,0,0]],
        ORCA: [[0,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,1,1,1,0,0,0,0], [0,0,1,1,1,1,1,1,0,0,0], [0,1,1,1,1,1,1,1,1,1,0], [1,1,2,1,1,1,1,1,1,1,1], [1,1,1,2,2,2,1,0,1,0,1], [0,0,0,0,1,1,0,0,0,0,0]],
        JELLY: [[0,1,1,1,0], [1,1,1,1,1], [1,1,1,1,1], [2,0,2,0,2], [2,0,2,0,2], [0,0,2,0,0]]
    };

    // --- 3. SYSTEM ---
    const canvas = document.getElementById('ocean');
    const ctx = canvas.getContext('2d', { alpha: false });

    let width, height;
    let entities = { fish: [], anglers: [], orcas: [], jellies: [] };

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    class Entity {
        constructor(x, y) {
            this.x = x; this.y = y; this.vx = 0; this.vy = 0; this.dead = false;
        }

        checkBoundaries() {
            // Horizontal Wrap
            if (this.x < -150) this.x = width + 150;
            if (this.x > width + 150) this.x = -150;

            // Vertical Bounce (Single Screen Mode)
            if (this.y > height + MARGIN) {
               this.vy *= -1;
               this.y = height + MARGIN - 5;
            }
            else if (this.y < -MARGIN) {
               this.vy *= -1;
               this.y = -MARGIN + 5;
            }
        }
    }

    class Fish extends Entity {
        constructor(x, y, vx, vy, color) {
            super(x, y);
            this.kind = 'fish';
            this.vx = (vx !== undefined) ? vx : (Math.random() - 0.5);
            this.vy = (vy !== undefined) ? vy : (Math.random() - 0.5);
            this.color = color || FISH_PALETTE[Math.floor(Math.random() * FISH_PALETTE.length)];
            this.scale = FISH_SIZE + (Math.random() * 2 - 1);
            this.personality = 0.8 + Math.random() * 0.4;
            this.wanderTheta = Math.random() * Math.PI * 2;
            this.facingRight = this.vx >= 0;
        }

        update() {
            let closeDx = 0, closeDy = 0, xVelAvg = 0, yVelAvg = 0, xPosAvg = 0, yPosAvg = 0;
            let neighbors = 0;
            let panic = false;

            const predators = [...entities.orcas, ...entities.anglers];
            for (let p of predators) {
                let dx = this.x - p.x; let dy = this.y - p.y;
                let rangeSq = (p.kind === 'orca') ? ORCA_PANIC_RANGE**2 : PANIC_RANGE**2;
                if ((dx*dx + dy*dy) < rangeSq) {
                    panic = true;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    this.vx += (dx/dist) * FEAR_FACTOR;
                    this.vy += (dy/dist) * FEAR_FACTOR;
                }
            }

            // Cursor fear
            if (mouseX > -9000) {
                let cdx = this.x - mouseX, cdy = this.y - mouseY;
                let cdSq = cdx*cdx + cdy*cdy;
                if (cdSq < PANIC_RANGE * PANIC_RANGE && cdSq > 0.01) {
                    panic = true;
                    let cd = Math.sqrt(cdSq);
                    this.vx += (cdx/cd) * FEAR_FACTOR * 0.6;
                    this.vy += (cdy/cd) * FEAR_FACTOR * 0.6;
                }
            }

            if (!panic) {
                for (let other of entities.fish) {
                    if (other === this) continue;
                    let dx = this.x - other.x; let dy = this.y - other.y;
                    if (Math.abs(dx) > VISUAL_RANGE || Math.abs(dy) > VISUAL_RANGE) continue;
                    let distSq = dx*dx + dy*dy;

                    if (distSq < VISUAL_RANGE_SQ) {
                        xVelAvg += other.vx; yVelAvg += other.vy;
                        xPosAvg += other.x; yPosAvg += other.y;
                        if (distSq < SEPARATION_DIST_SQ) {
                            closeDx += (this.x - other.x);
                            closeDy += (this.y - other.y);
                        }
                        neighbors++;
                    }
                }
            }

            if (neighbors > 0 && !panic) {
                xVelAvg /= neighbors; yVelAvg /= neighbors;
                xPosAvg /= neighbors; yPosAvg /= neighbors;
                this.vx += (xVelAvg - this.vx) * ALIGNMENT_FACTOR;
                this.vy += (yVelAvg - this.vy) * ALIGNMENT_FACTOR;
                this.vx += (xPosAvg - this.x) * COHESION_FACTOR;
                this.vy += (yPosAvg - this.y) * COHESION_FACTOR;
            }

            this.vx += closeDx * SEPARATION_FACTOR;
            this.vy += closeDy * SEPARATION_FACTOR;

            if (!panic) {
                this.wanderTheta += (Math.random() - 0.5) * 0.1;
                this.vx += Math.cos(this.wanderTheta) * WANDER_FACTOR;
                this.vy += Math.sin(this.wanderTheta) * WANDER_FACTOR;
            }

            if (this.x < MARGIN) this.vx += TURN_FACTOR;
            if (this.x > width - MARGIN) this.vx -= TURN_FACTOR;

            // Vertical Soft Turn
            if (this.y < MARGIN) this.vy += TURN_FACTOR;
            if (this.y > height - MARGIN) this.vy -= TURN_FACTOR;

            // Smooth U-turn near walls
            const UT = 75; let uf;
            let eL = Math.max(0, (UT - this.x) / UT);
            let eR = Math.max(0, (this.x - (width - UT)) / UT);
            let eT = Math.max(0, (UT - this.y) / UT);
            let eB = Math.max(0, (this.y - (height - UT)) / UT);
            if (eL > 0) { uf = eL*eL*0.15; this.vx += uf; this.vy += (this.vy >= 0 ? 1 : -1)*uf*0.5; }
            if (eR > 0) { uf = eR*eR*0.15; this.vx -= uf; this.vy += (this.vy >= 0 ? 1 : -1)*uf*0.5; }
            if (eT > 0) { uf = eT*eT*0.15; this.vy += uf; this.vx += (this.vx >= 0 ? 1 : -1)*uf*0.5; }
            if (eB > 0) { uf = eB*eB*0.15; this.vy -= uf; this.vx += (this.vx >= 0 ? 1 : -1)*uf*0.5; }

            this.vx *= 0.99; this.vy *= 0.99;

            let speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
            let currentMax = panic ? MAX_SPEED * 1.6 : MAX_SPEED * this.personality;
            let currentMin = MIN_SPEED * this.personality;
            if (speed > currentMax) {
                this.vx = (this.vx/speed) * currentMax;
                this.vy = (this.vy/speed) * currentMax;
            } else if (speed < currentMin && speed > 0.01) {
                this.vx = (this.vx/speed) * (speed + 0.015);
                this.vy = (this.vy/speed) * (speed + 0.015);
            }

            this.x += this.vx; this.y += this.vy;
            this.checkBoundaries();
        }

        checkBoundaries() {
            if (this.x < 0) { this.x = 2; this.vx = Math.abs(this.vx) * 0.3 + 0.05; }
            if (this.x > width) { this.x = width - 2; this.vx = -(Math.abs(this.vx) * 0.3 + 0.05); }
            if (this.y < 0) { this.y = 2; this.vy = Math.abs(this.vy) * 0.3 + 0.05; }
            if (this.y > height) { this.y = height - 2; this.vy = -(Math.abs(this.vy) * 0.3 + 0.05); }
        }

        draw() {
            if (this.vx > 0.35) this.facingRight = true;
            else if (this.vx < -0.35) this.facingRight = false;
            drawSprite(SPRITES.FISH, this.x, this.y, this.scale, this.facingRight, (val) => (val===1) ? this.color : '#FFF');
        }
    }

    class Angler extends Entity {
        constructor(x, y, vx, vy) {
            super(x, y);
            this.kind = 'angler';
            this.vx = vx || (Math.random() - 0.5) * 0.9;
            this.vy = vy || (Math.random() - 0.5) * 0.9;
            this.scale = ANGLER_SIZE;
            this.facingRight = this.vx >= 0;
        }
        update() {
            this.vx *= 0.995; this.vy *= 0.995;
            this.vx += (Math.random()-0.5)*0.04;
            this.vy += (Math.random()-0.5)*0.04;

            // Chase nearest fish
            let nearDist = Infinity, nearFish = null;
            for (let f of entities.fish) {
                let dx = f.x - this.x, dy = f.y - this.y;
                let d = dx*dx + dy*dy;
                if (d < nearDist) { nearDist = d; nearFish = f; }
            }
            if (nearFish && nearDist < 200*200) {
                let dist = Math.sqrt(nearDist);
                this.vx += ((nearFish.x - this.x)/dist) * 0.03;
                this.vy += ((nearFish.y - this.y)/dist) * 0.03;
            }

            // Flee from orcas
            for (let o of entities.orcas) {
                let dx = this.x - o.x, dy = this.y - o.y;
                let distSq = dx*dx + dy*dy;
                if (distSq < 150*150 && distSq > 0.01) {
                    let dist = Math.sqrt(distSq);
                    this.vx += (dx/dist) * 0.08;
                    this.vy += (dy/dist) * 0.08;
                }
            }

            // Soft boundaries
            if (this.x < MARGIN) this.vx += 0.04;
            if (this.x > width - MARGIN) this.vx -= 0.04;
            if (this.y < MARGIN) this.vy += 0.04;
            if (this.y > height - MARGIN) this.vy -= 0.04;

            // Speed limit
            let speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
            if (speed > 0.5) { this.vx = (this.vx/speed)*0.5; this.vy = (this.vy/speed)*0.5; }

            this.x += this.vx; this.y += this.vy;
            this.checkBoundaries();
        }
        draw() {
            if (this.vx > 0.1) this.facingRight = true;
            else if (this.vx < -0.1) this.facingRight = false;
            drawSprite(SPRITES.ANGLER, this.x, this.y, this.scale, this.facingRight, (val) => {
                if(val===1) return 'rgb(64, 51, 89)';
                if(val===2) return 'rgb(255, 255, 153)';
                return 'rgb(255, 51, 51)';
            });
        }
    }

    class Orca extends Entity {
        constructor(x, y, vx, vy) {
            super(x, y);
            this.kind = 'orca';
            this.scale = ORCA_SIZE;
            this.angle = Math.random() * Math.PI * 2;
            this.vx = Math.cos(this.angle) * 0.3;
            this.vy = Math.sin(this.angle) * 0.1;
            this.facingRight = this.vx >= 0;
        }
        update() {
            // Wander drift (additive, not overwriting)
            this.angle += 0.005;
            this.vx += Math.cos(this.angle) * 0.01;
            this.vy += Math.sin(this.angle * 0.7) * 0.005;

            // Chase cursor
            if (mouseX > -9000) {
                let dx = mouseX - this.x, dy = mouseY - this.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 450 && dist > 1) {
                    let force = 0.15 * (1 - dist/450);
                    this.vx += (dx/dist) * force;
                    this.vy += (dy/dist) * force;
                }
            }

            // Friction
            this.vx *= 0.985; this.vy *= 0.985;

            // Soft boundaries
            if (this.x < MARGIN) this.vx += 0.04;
            if (this.x > width - MARGIN) this.vx -= 0.04;
            if (this.y < MARGIN) this.vy += 0.04;
            if (this.y > height - MARGIN) this.vy -= 0.04;

            // Speed limit
            let speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
            if (speed > 0.7) { this.vx = (this.vx/speed) * 0.7; this.vy = (this.vy/speed) * 0.7; }

            this.x += this.vx; this.y += this.vy;
            this.checkBoundaries();
        }
        draw() {
            if (this.vx > 0.1) this.facingRight = true;
            else if (this.vx < -0.1) this.facingRight = false;
            drawSprite(SPRITES.ORCA, this.x, this.y, this.scale, !this.facingRight, (val) => (val===1)?'rgb(77, 102, 128)':'rgb(230, 230, 230)');
        }
    }

    class Jelly extends Entity {
        constructor(x, y) {
            super(x, y);
            this.kind = 'jelly';
            this.scale = 4 + Math.random() * 2;
            this.speed = 0.2 + Math.random() * 0.2;
            this.wobble = Math.random() * Math.PI * 2;
            this.direction = Math.random() > 0.5 ? 1 : -1;
        }
        update() {
            this.y += this.speed * this.direction;
            this.wobble += 0.04;
            this.x += Math.sin(this.wobble) * 0.4;

            if (this.y < -50) this.direction = 1;
            if (this.y > height + 50) this.direction = -1;
        }
        draw() {
            drawSprite(SPRITES.JELLY, this.x, this.y, this.scale, false, () => 'rgba(200, 180, 255, 0.25)');
        }
    }

    function drawSprite(grid, x, y, scale, flip, colorFunc) {
        if (x < -50 || x > width + 50 || y < -50 || y > height + 50) return;
        const iX = Math.floor(x), iY = Math.floor(y);
        const cols = grid[0].length;
        const w = scale + 1, h = scale + 1;
        for (let val = 1; val <= 3; val++) {
            ctx.beginPath();
            let has = false;
            for (let r = 0; r < grid.length; r++) {
                for (let c = 0; c < grid[r].length; c++) {
                    if (grid[r][c] !== val) continue;
                    let drawC = flip ? c : (cols - 1 - c);
                    ctx.rect(iX + drawC * scale, iY + r * scale, w, h);
                    has = true;
                }
            }
            if (has) { ctx.fillStyle = colorFunc(val); ctx.fill(); }
        }
    }

    // --- MAIN LOOP ---
    function init() {
        entities = { fish: [], anglers: [], orcas: [], jellies: [] };
        for(let i=0; i<FISH_COUNT; i++) entities.fish.push(new Fish(Math.random()*width, Math.random()*height));
        for(let i=0; i<ANGLER_COUNT; i++) entities.anglers.push(new Angler(Math.random()*width, Math.random()*height));
        for(let i=0; i<ORCA_COUNT; i++) entities.orcas.push(new Orca(Math.random()*width, Math.random()*height));
        for(let i=0; i<JELLY_COUNT; i++) entities.jellies.push(new Jelly(Math.random()*width, Math.random()*height));
        lastTime = performance.now();
        requestAnimationFrame(animate);
    }

    let lastTime = 0, accumulator = 0;
    const TICK_DURATION = 33;

    function animate(currentTime) {
        requestAnimationFrame(animate);
        let deltaTime = Math.min(currentTime - lastTime, 100);
        lastTime = currentTime;
        accumulator += deltaTime;
        while (accumulator >= TICK_DURATION) {
            Object.values(entities).forEach(list => {
                for (let i = list.length - 1; i >= 0; i--) {
                    list[i].update();
                    if (list[i].dead) list.splice(i, 1);
                }
            });

            // Predator separation
            const allPreds = [...entities.orcas, ...entities.anglers];
            for (let i = 0; i < allPreds.length; i++) {
                for (let j = i + 1; j < allPreds.length; j++) {
                    let dx = allPreds[j].x - allPreds[i].x, dy = allPreds[j].y - allPreds[i].y;
                    let distSq = dx*dx + dy*dy;
                    if (distSq < 3600 && distSq > 0.01) {
                        let dist = Math.sqrt(distSq);
                        let pf = (60 - dist) * 0.02;
                        let nx = dx/dist, ny = dy/dist;
                        allPreds[i].vx -= nx*pf; allPreds[i].vy -= ny*pf;
                        allPreds[j].vx += nx*pf; allPreds[j].vy += ny*pf;
                    }
                }
            }

            accumulator -= TICK_DURATION;
        }
        // Day/night update
        dnCounter++;
        if (dnCounter % 90 === 1) {
            const now = new Date();
            const h = now.getHours() + now.getMinutes() / 60;
            const dn = getDayNightColors(h);
            waterTop = dn.top; waterBottom = dn.bottom;
        }

        let grad = ctx.createLinearGradient(0, 0, 0, height);
        grad.addColorStop(0, waterTop); grad.addColorStop(1, waterBottom);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, width, height);

        [entities.jellies, entities.orcas, entities.anglers, entities.fish].forEach(list => {
            for (let i = 0; i < list.length; i++) list[i].draw();
        });
    }

    canvas.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
    canvas.addEventListener('mouseleave', () => { mouseX = -9999; mouseY = -9999; });

    init();
</script>
</body>
</html>
